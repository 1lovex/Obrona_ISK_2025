# Pytanie 1 - Paradygmaty programowania obiektowego

## **Kuba**

Paradygmat to zbiór mechanizmów działania i wzorców, które definiują sposób realizacji programu. Paradygmat programowania obiektowego (ang. Object-Oriented Programming – OOP) ma stanowić ułatwienie w pisaniu i utrzymywaniu kodu, pozwalając na jego wielokrotne wykorzystanie w różnych projektach.

W przeciwieństwie do programowania proceduralnego, gdzie dane i funkcje są od siebie odseparowane, OOP opiera się na obiektach. Są to twory łączące w sobie dane (pola/atrybuty) oraz zachowania (metody). Obiekty komunikują się ze sobą, aby wspólnie realizować złożone zadania.

---

### 1. Klasa a Obiekt

- **Klasa**: To abstrakcyjny projekt lub "przepis", który definiuje cechy i zachowania, jakie będą posiadać jej instancje. Na przykład klasa Pies określa, że każdy pies ma oczy i potrafi szczekać.
  - **Pola (atrybuty)**: Zmienne przechowujące dane, np. kolor sierści, wiek.
  - **Metody**: Funkcje definiujące zachowania, np. szczekanie, bieganie.
- **Obiekt**: To konkretna instancja danej klasy (konkretny pies, np. "Burek").
  - Przykład: Obiekt "Burek" może mieć atrybuty: kolor = "biały", wiek = 3, i metody: szczekaj(), biegaj().

Warto zauważyć, że języki różnie implementują te pojęcia. Java czy Python narzucają strukturę obiektową (często każda klasa niejawnie dziedziczy po bazowej klasie Object), podczas gdy C++ jest językiem hybrydowym, pozwalającym łączyć podejście obiektowe ze strukturalnym. Istnieją też języki oparte na prototypach (np. JavaScript), gdzie nowe obiekty tworzy się na bazie już istniejących, a nie sztywnych klas.

- **Przykład w kodzie (Python)**:

  ```python
  class Pies:
      def __init__(self, imie, kolor):
          self.imie = imie
          self.kolor = kolor

      def szczekaj(self):
          print("Hau!")

  burek = Pies("Burek", "biały")  # Tworzenie obiektu
  burek.szczekaj()  # Wywołanie metody
  ```

---

### 2. Filary Paradygmatu Obiektowego

Główne zalety obiektowości – takie jak modularność, czytelność i łatwość rozbudowy – wynikają z czterech kluczowych założeń:

#### 2.1 Abstrakcja

Abstrakcja to proces upraszczania problemu poprzez izolowanie kluczowych aspektów i ignorowanie zbędnych detali. Pozwala nam ona traktować fragment kodu jako interfejs (np. komunikacja z Bazą Danych), nie wnikając w to, jak dokładnie jest zrealizowany "pod spodem".

- **Zalety abstrakcji:**
  - Upraszcza złożone systemy.
  - Umożliwia koncentrację na istotnych aspektach.
  - Wspiera wielokrotne wykorzystanie kodu.

> Przykład: Kierowca samochodu nie musi znać budowy silnika, by prowadzić; wystarczy mu wiedza o działaniu kierownicy i pedałów. Podobnie użytkownik ekspresu do kawy oczekuje napoju po wciśnięciu guzika, nie analizując ciśnienia wody wewnątrz urządzenia.

> Dodatkowy przykład: W programowaniu, interfejsy w językach jak Java czy C# definiują metody bez implementacji, pozwalając na abstrakcyjne traktowanie różnych klas implementujących ten sam interfejs.

#### 2.2 Enkapsulacja (Hermetyzacja)

Polega na ukrywaniu wewnętrznego stanu obiektu przed światem zewnętrznym. Zmiany w obiekcie mogą być dokonywane wyłącznie za pomocą jego własnych metod. Zwiększa to bezpieczeństwo i odporność kodu na błędy.

**Parametry dostępu:**

- `private`: dostęp tylko w obrębie danej klasy.
- `protected`: dostęp dla klasy i jej potomków (klas dziedziczących).
- `public`: dostęp z każdego miejsca w programie.

- **Zalety enkapsulacji:**
  - Zapobiega nieautoryzowanym zmianom stanu.
  - Ułatwia testowanie i debugowanie.
  - Wspiera zasadę pojedynczej odpowiedzialności.

> Przykład (Automat z napojami): Automat to obiekt. Jego polem prywatnym (private) jest liczba puszek w środku oraz kasetka z pieniędzmi. Gdyby te dane były publiczne, każdy mógłby po prostu wyciągnąć puszki ręką. Enkapsulacja sprawia, że interfejsem publicznym (public) są tylko przyciski wyboru. Kiedy naciskasz przycisk, to automat sam wewnątrz siebie sprawdza, czy wrzuciłeś monetę i czy puszka jest dostępna, a dopiero potem wydaje napój i aktualizuje swój stan.

#### 2.3 Dziedziczenie

Pozwala na tworzenie hierarchicznych struktur klas, gdzie klasa pochodna ("dziecko") przejmuje funkcjonalność klasy bazowej ("rodzica") i może ją rozszerzać bez duplikowania kodu.

- **Typy dziedziczenia:**
  - **Pojedyncze**: Klasa dziedziczy po jednej klasie bazowej.
  - **Wielokrotne**: Klasa dziedziczy po kilku klasach bazowych (np. w C++, Python).
  - **Hierarchiczne**: Kilka klas dziedziczy po jednej bazowej.
  - **Wielopoziomowe**: Klasa dziedziczy po innej, która już dziedziczy.

**Dziedziczenie wielokrotne:** Niektóre języki (C++, Python) pozwalają jednej klasie dziedziczyć po kilku rodzicach. Jest to potężne narzędzie, ale ryzykowne – może prowadzić do tzw. problemu diamentowego (niejednoznaczność przy wywoływaniu metod o tej samej nazwie z dwóch różnych ścieżek dziedziczenia).

- **Przykład kodu (Python)**:

  ```python
  class Zwierze:
      def daj_glos(self):
          pass

  class Pies(Zwierze):
      def daj_glos(self):
          print("Hau!")

  class Kot(Zwierze):
      def daj_glos(self):
          print("Miau!")
  ```

#### 2.4 Polimorfizm (Wielopostaciowość)

Umożliwia używanie jednej referencji do obiektów różnych typów, o ile mają one wspólnego przodka. Dzięki temu zachowanie programu może zmieniać się w zależności od kontekstu (typu obiektu).

- **Polimorfizm statyczny (wczesne wiązanie):** Decyzja o typie zapada podczas kompilacji (np. przeciążanie metod lub operatorów).
  - Przykład: Przeciążanie funkcji w C++: `void func(int x)` i `void func(double x)`.
- **Polimorfizm dynamiczny (późne wiązanie):** Wybór metody następuje w czasie wykonywania programu (nadpisywanie metod wirtualnych).

  - Przykład: W językach jak Java, metody wirtualne są nadpisywane w klasach pochodnych.

- **Zalety polimorfizmu:**
  - Zwiększa elastyczność kodu.
  - Umożliwia rozszerzanie funkcjonalności bez zmiany istniejącego kodu.
  - Wspiera zasadę otwarte-zamknięte (Open-Closed Principle).

> Przykład: Mamy klasę Zwierzę z metodą `dajGlos()`. Wywołując tę samą metodę na obiekcie klasy Pies, usłyszymy szczekanie, a na obiekcie klasy Ryba – jedynie ciszę lub bulgotanie.

---

### 3. Wzorce Projektowe (RACZEJ BONUS)

Wzorce to sprawdzone rozwiązania często powracających problemów programistycznych. Dzielimy je na trzy kategorie:

- **Konstrukcyjne** (np. Fabryka, Singleton) – opisują proces tworzenia obiektów.
  - Fabryka: Tworzy obiekty bez specyfikowania dokładnej klasy.
  - Singleton: Zapewnia, że klasa ma tylko jedną instancję.
- **Strukturalne** (np. Adapter, Dekorator) – opisują, jak łączyć obiekty w większe struktury.
  - Adapter: Umożliwia współpracę między niezgodnymi interfejsami.
  - Dekorator: Dodaje nowe funkcjonalności do obiektu bez zmiany jego struktury.
- **Behawioralne** (np. Strategia, Null Object) – określają sposób komunikacji i odpowiedzialność obiektów.
  - Strategia: Definiuje rodzinę algorytmów i umożliwia ich wymienne używanie.
  - Null Object: Zapewnia domyślny obiekt, który nic nie robi, aby uniknąć null pointer exceptions.

> Uwaga: Należy wystrzegać się "antywzorców", takich jak Złoty Młotek (używanie znanej nam technologii do wszystkiego) czy przesadne stosowanie wzorców tam, gdzie nie są one potrzebne.

---

### Podsumowanie

Programowanie obiektowe rewolucjonizuje organizację kodu poprzez modularność, jednak nie jest wolne od wad. Przez posiadanie przez obiekty wewnętrznego stanu, programowanie współbieżne (wielowątkowe) staje się trudniejsze, wymagając dodatkowych zabezpieczeń przed wyścigami danych. Mimo to, czytelność i łatwość zarządzania dużymi projektami sprawiają, że pozostaje ono jednym z najważniejszych paradygmatów współczesnej informatyki.

- **Zalety OOP:**

  - Modularność: Łatwe dzielenie kodu na niezależne części.
  - Czytelność: Kod jest bardziej zrozumiały i łatwiejszy w utrzymaniu.
  - Wielokrotne wykorzystanie: Klasy i obiekty można używać w różnych kontekstach.
  - Łatwość rozszerzania: Dziedziczenie i polimorfizm umożliwiają dodawanie nowych funkcjonalności.

- **Wady OOP:**
  - Złożoność: Dla małych projektów może być overkill.
  - Wydajność: Obiekty mogą być mniej efektywne niż proceduralne podejście w niektórych przypadkach.
  - Trudności z współbieżnością: Stan obiektów może prowadzić do błędów w wielowątkowości.
  - Krzywa uczenia się: Wymaga zrozumienia nowych koncepcji.

---

---

## Stachu

### Filary OOP według Stacha

- **Enkapsulacja (Hermetyzacja):**
  Zapewnia, że obiekt nie może zmieniać stanu wewnętrznego innych obiektów w nieoczekiwany sposób. Tylko własne metody obiektu są uprawnione do zmiany jego stanu. Każdy typ obiektu prezentuje innym obiektom swój interfejs, który określa dopuszczalne metody współpracy.

- **Dziedziczenie:**
  Porządkuje i wspomaga polimorfizm i enkapsulację dzięki umożliwieniu definiowania i tworzenia specjalizowanych obiektów na podstawie bardziej ogólnych. Dla obiektów specjalizowanych nie trzeba redefiniować całej funkcjonalności, lecz tylko tę, której nie ma obiekt ogólniejszy.

- **Polimorfizm:**
  Polimorfizm pozwala wartości lub zmiennej mieć więcej niż jeden typ i umożliwia wykonanie danej operacji na wartościach więcej niż jednego typu. W programowaniu obiektowym polimorfizm polega na zapewnieniu jednego interfejsu dla jednostek różnych typów danych. Koncepcja ta została zapożyczona z zasady biologii, w której organizm lub gatunek może mieć wiele różnych form lub stadiów.

  - _Polimorfizm ad hoc_: definiuje wspólny interfejs dla arbitralnego zestawu indywidualnie określonych typów.
  - _Polimorfizm parametryczny_: nie określa konkretnych typów i zamiast tego używa abstrakcyjnych symboli, które mogą zastąpić dowolny typ.
  - _Podtypowanie_ (zwane także polimorfizmem podtypu lub polimorfizmem inkluzji): gdy nazwa oznacza instancje wielu różnych klas powiązanych wspólną nadklasą.

- **Abstrakcja:**
  Każdy obiekt w systemie służy jako model abstrakcyjnego „wykonawcy”, który może wykonywać pracę, opisywać i zmieniać swój stan oraz komunikować się z innymi obiektami w systemie bez ujawniania, w jaki sposób zaimplementowano dane cechy. Procesy, funkcje lub metody mogą być również abstrahowane, a kiedy tak się dzieje, konieczne są rozmaite techniki rozszerzania abstrakcji.

---
