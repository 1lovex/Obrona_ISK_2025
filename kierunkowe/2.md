# Pytanie 2 - Arytmetyka stało- i zmiennoprzecinkowa.

## Kuba

### Arytmetyka Stało- i Zmiennoprzecinkowa – Kompendium Wiedzy

Zrozumienie arytmetyki komputerowej to zrozumienie kompromisu między zakresem, precyzją a skomplikowaniem sprzętowym procesora.

---

### 1. Arytmetyka Stałoprzecinkowa (Liczby Całkowite)

W tym systemie każdy bit ma przypisaną stałą wagę. Jest on podstawą działania liczników, indeksów tablic i operacji logicznych.

**Systemy reprezentacji:**

- **NKB (Naturalny Kod Binarny):** Najprostszy system dla liczb dodatnich. Wartość to suma wag (1, 2, 4, 8...). Brak możliwości zapisu liczb ujemnych.
  - **Przykład:** Liczba 5 w 4-bitowym NKB: 0101 (1 + 4 = 5).
- **U2 (Kod Uzupełnieniowy do Dwóch):** Najważniejszy system w informatyce. Najstarszy bit (MSB) ma wagę ujemną (np. na 8 bitach jest to -128).
  - **Asymetria zakresu:** W U2 możemy zapisać o jedną liczbę ujemną więcej niż dodatnią (np. od -128 do 127). Wynika to z faktu, że zero "zabiera" jedno miejsce w puli liczb dodatnich.
  - **Zaleta sprzętowa:** Odejmowanie realizowane jest jako dodawanie liczby przeciwnej ($A - B = A + (-B)$). Procesor nie potrzebuje osobnego układu do odejmowania.
  - **Przykład:** Liczba -3 w 4-bitowym U2: 1101 (odwrócony 0011 + 1 = 1100 + 1 = 1101).
- **System znak-moduł:** Pierwszy bit to znak, reszta to wartość. Mało wydajny, bo posiada "podwójne zero" (+0 i -0), co komplikuje porównywanie liczb.
  - **Przykład:** +5: 0101, -5: 1101.
- **System obciążony (Bias):** Do każdej liczby dodajemy stałą wartość (nadmiar). Dzięki temu wszystkie liczby są dodatnie w kodzie binarnym, co pozwala na ich błyskawiczne porównywanie przez procesor (kolejność kodów odpowiada kolejności liczb).
  - **Przykład:** Dla bias 8, liczba 0: 1000, liczba 5: 1101.

### 2. Arytmetyka Zmiennoprzecinkowa (Standard IEEE 754)

Stworzona, by symulować notację naukową i obsługiwać gigantyczne rozpiętości wartości (od atomu do galaktyki).

**Postać i wzór liczby:**

Każda liczba zmiennoprzecinkowa jest reprezentowana przez cztery składowe ($S$, $\beta$, $M$, $E$). Ogólny wzór matematyczny na wartość liczby to:

$$X = (-1)^S \cdot M \cdot \beta^E$$

Gdzie poszczególne elementy oznaczają:

- $S$ (Sign): Bit znaku liczby. Przyjmuje wartość 0 dla liczb dodatnich lub 1 dla liczb ujemnych. Określa, czy liczba jest dodatnia, czy ujemna.
- $M$ (Mantissa): Mantysa, czyli część ułamkowa liczby zawierająca cyfry znaczące. W standardzie IEEE 754 mantysa jest normalizowana i zawiera ukrytą jedynkę (najstarszy bit nie jest zapisany, aby zaoszczędzić miejsce).
- $\beta$ (Base): Podstawa systemu liczbowego, w którym zapisana jest liczba. W komputerach prawie zawsze $\beta = 2$ (system binarny), choć teoretycznie może być inny.
- $E$ (Exponent): Wykładnik potęgi, który określa skalę liczby poprzez przesunięcie przecinka. Jest zapisany w systemie obciążonym (bias), aby uniknąć problemów z liczbami ujemnymi.

W standardzie binarnym IEEE 754, uwzględniając mechanizm obciążenia wykładnika i ukrytego bitu, postać liczby znormalizowanej to:

$$X = (-1)^S \cdot (1.f) \cdot 2^{E - Bias}$$

**Struktura bitowa (Bit layout):**

Liczba w pamięci zawsze dzieli się na trzy pola w stałej kolejności:

- Bit znaku (1 bit): Zawsze na początku.
- Wykładnik (E): Zapisany w systemie obciążonym (np. +127 dla 32 bitów).
- Mantysa (M/f): Część ułamkowa.

**Kluczowe mechanizmy "pod maską":**

- **Normalizacja i ukryta jedynka:** Aby nie marnować bitów, zawsze przesuwamy przecinek tak, by przed nim była jedynka ($1.xxxx$). Skoro zawsze tam jest, to jej nie zapisujemy. Dzięki temu w 32-bitowym float mamy de facto 24 bity precyzji w 23-bitowej mantysie.
  - **Przykład:** Liczba 5.0 = 101.0 w binarnym, znormalizowana: 1.01 × 2², ukryta jedynka: mantysa 01.
- **Liczby zdenormalizowane (Stopniowy niedomiar):** Gdy wykładnik składa się z samych zer, "ukryta jedynka" staje się zerem. Pozwala to na łagodne przejście do zera zamiast gwałtownego błędu, co ratuje precyzję w obliczeniach naukowych.
  - **Przykład:** Bardzo mała liczba, np. 2^{-126} × 0.000...1.

**Precyzje:**

- **Pojedyncza (float):** 32 bity (1 bit znaku, 8 bitów wykładnika, 23 bity mantysy).
- **Podwójna (double):** 64 bity (1 bit znaku, 11 bitów wykładnika, 52 bity mantysy).
- **Połowiczna (half):** 16 bitów (1 bit znaku, 5 bitów wykładnika, 10 bitów mantysy).

### 3. Stany Specjalne – Więcej niż liczby

IEEE 754 definiuje zachowanie procesora w sytuacjach krytycznych:

- **Zero (+0 i -0):** Choć matematycznie to samo, w komputerze znak zera może informować o kierunku, z którego nastąpiło przybliżenie do zera (ważne w analizie granic).
- **Nieskończoność ($\pm \infty$):** Wynik dzielenia liczby przez zero lub przekroczenia zakresu (Overflow). Można na niej wykonywać operacje, np. $5 + \infty = \infty$.
- **NaN (Not a Number):** "Nie-liczba". Wynik błędów typu $0/0$ lub $\sqrt{-1}$.
  - **QNaN (Quiet):** Cicho przechodzi przez obliczenia, nie przerywając programu.
  - **SNaN (Signaling):** Natychmiast zgłasza błąd procesora (pułapkę).

### 4. Zaokrąglanie i bity GRS (Klucz do precyzji)

Ponieważ mantysa ma ograniczoną długość, procesor "widzi" nieco więcej bitów podczas obliczeń – są to bity G (Guard), R (Round) i S (Sticky).

- **Bit Sticky:** To "pamięć" o jakiejkolwiek jedynce, która została odrzucona dalej.
- **Round to nearest, ties to even (Do najbliższej, parzystej):** To standard. Jeśli wynik jest dokładnie pośrodku (np. 2.5), zaokrąglamy do liczby parzystej (2.0).
  - **Dlaczego?** Statystycznie, w połowie przypadków zaokrąglamy w górę, a w połowie w dół. Błędy się znoszą.
  - **Przykład:** Zaokrąglanie 1.5 do najbliższej parzystej: 2.0 (bo 2 jest parzyste).

### 5. Wyjątki FPU (Co może pójść nie tak?)

Podczas odpowiedzi warto wymienić 5 flag błędów:

- **Invalid Operation:** (NaN) – operacja bez sensu.
- **Division by Zero:** Dzielenie przez zero skończonej liczby.
- **Overflow:** Wynik zbyt duży (ucieczka do nieskończoności).
- **Underflow:** Wynik zbyt mały (staje się liczbą zdenormalizowaną lub zerem).
- **Inexact:** Najczęstszy – informuje, że wynik musiał zostać zaokrąglony.

### 6. Dlaczego kolejność działań ma znaczenie?

W matematyce $(A + B) + C = A + (B + C)$. W komputerze **NIE**.
Jeśli do bardzo dużej liczby dodasz bardzo małą, ta mała może "zniknąć", bo nie zmieści się w precyzji mantysy. Jeśli jednak najpierw dodasz do siebie wiele małych liczb, a potem wynik dodasz do dużej – wynik będzie dokładniejszy.

**Przykład:** Dodaj 1e10 + 1e-10 vs. (1e10 + 1e-10) + 1e-10. W pierwszym przypadku 1e-10 znika, w drugim może być lepiej.

**Tabela porównawcza:**

| Cecha           | Stało-przecinkowe               | Zmienna-przecinkowe                               |
| --------------- | ------------------------------- | ------------------------------------------------- |
| Gęstość liczb   | Rozłożone równomiernie na osi.  | Gęsto przy zerze, rzadko przy dużych wartościach. |
| Błąd            | Bezwzględny (wynika z zakresu). | Względny (procentowy błąd mantysy).               |
| Koszt sprzętowy | Tanie i szybkie (ALU).          | Droższe i wolniejsze (FPU).                       |
| Problem 0.1+0.2 | Nie dotyczy (liczby całkowite). | Klasyczny błąd reprezentacji ułamka okresowego.   |

---

---

## Stachu

### Jak to u Patronite'a było, U2, pojedyncza, podwójna i połowiczna precyzja

[GOAT](https://www.youtube.com/@TomaszRzymyszkiewicz)

---

#### Stało-przecinkowa

Liczba reprezentowana jest w postaci binarnej albo U2 (najstarszy bit - znak). Do przedstawienia wartości ułamkowej, ustala się pozycję przecinka, która nie ulega zmianie. Kolejne bity reprezentują wartość funkcji $x \cdot 2^i$, gdzie $x$ to wartość \{0, 1\} a $i$ to pozycja bitu zależna od miejsca przecinka. Dodawanie i odejmowanie są analogiczne co w układzie decymalnym.

**Mnożenie:** Istnieje kilka metod:

- Normalna (dodawanie i jeszcze więcej dodawania)
- B/R
- Bootha
- Booth – McSorley'a

**Dzielenie:**

- Odtwarzające
- Nieodtwarzające

**Przykład:** Dla 4-bitowej stałoprzecinkowej z przecinkiem po 2 bitach, liczba 3.5: 0011 (3 + 0.5).

---

#### Zmienna-przecinkowa

Liczba reprezentowana jest poprzez bit-znak (S), eksponent (E) i mantysę (M). Standard IEEE 754. W zależności od precyzji długości poszczególnych obszarów różni się. Bit-znak, jak nazwa wskazuje, zawsze jest najstarszym bitem liczby zmiennoprzecinkowej. Eksponent to potęga, mantysa to wartość ułamka. Wartość liczby zmiennoprzecinkowej opisuje funkcja $S \cdot (1.)M \cdot 2^E$. Aby oszczędzić miejsce, najstarszy bit liczby w notacji nie jest reprezentowany w mantysie, mantysa posiada wyłącznie informację o ułamku.

**Precyzje:**

- **Pojedyncza:**
  - Eksponent: 8 bitów
  - Mantysa: 23 bity
- **Podwójna:**
  - Eksponent: 11 bitów
  - Mantysa: 52 bity
- **Połowiczna:**
  - Eksponent: 5 bitów
  - Mantysa: 10 bitów

Liczby zmiennoprzecinkowe dzielimy na dwie grupy, znormalizowane i zdenormalizowane. Dla liczb zdenormalizowanych, dodatkowa jedynka zmieniana jest na zero w funkcji obliczania wartości liczby. Pojawia się, gdy występuje niedomiar (ang. underflow). W dodawaniu i odejmowaniu należy wyrównać wartość eksponentu i zdenormalizować jedną z liczb. Mnożenie i dzielenie działają normalnie.

**Przykład:** Liczba 5.0 w pojedynczej precyzji: Znak 0, Eksponent 132 (128 + 4), Mantysa 00000000000000000000000 (ukryta 1, więc 1.0 × 2^4 = 16, czekaj, poprawka: 5.0 = 101.0 bin = 1.01 × 2^2, eksponent 2 + 127 = 129, mantysa 010...).
